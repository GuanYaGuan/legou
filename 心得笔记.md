#### 接口文档: https://www.apizza.net/project/14fa6a9c4a45468acf235da89ee8e1be/browse  密码: bufanjun

##### 移动端的适配问题:

1. 媒体查询: `@media "target="_blank">MDN`

   ```css
   <!-- 例如：有的 screen 前面有 only -->
   @media screen and (max-width: 1200px) {
       .box {
           background-color: yellow;
       }
   }
   <!-- screen 可以省略，填上screen 是告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印，可以写成这种形式 -->
   @media (min-width: 960px){
     .box {
         background-color: yellow;
     }
   }
   <!-- 也可以连写：表示当页面宽度大于960 或者 小于1200的时候执行内部代码 -->
   @media screen and (min-width:960px) and (max-width:1200px){
       .box {
           background-color: yellow;
       }
   }
   ```

2. 我们在 `vue` 项目中使用的是 flexible和 `postcss-px2rem`

   flexible 会为页面根据屏幕自动添加标签, 动态控制 initial-scale maximum-scale minimum-scale 等属性的值

   `postcss-px2rem` 会将 像素(px) 转换成 rem, rem会根据标签的 font-size 值来计算出结果

   + 安装: `npm install lib-flexible postcss-px2rem  `

**注意:** *在vue.config.js 中配置文件完毕之后需要重启服务*

如果 vue-cli 使用的是 5.几的版本 postcss-px2rem 配置重启后会报错, 需要给 vue-cli 降级至 4.几

### git 常用命令

```git
git init // 初始化 git
git add . // 将所有文件提交到缓存区
git commit -m '提交的描述信息'
git remote add origin // origin 后面填写的是 git 远程仓库的地址
git branch dev // dev 是你在仓库 main 主分支下 创建的 分支名称
git branch // 查看 分支 主分支前面带有星号
git checkout dev // 切换到 dev 的分支
git push origin dev // 将本地代码 push 进 远程仓库分支 dev 当中
```

书写 css 样式时, 为了不让边框 1px 适配移动端之后有毛边, 可以这样书写 1Px

### axios封装

其中我们会使用 vant 的 Toast 轻提示, ***注意:***    这里不需要 `Vue.use(Toast);`

### 搜索框的三个页面之间的切换

搜索框的

第一个页面是 历史记录 和 关键词 页面

第二个页面是 搜索框输入时 的搜索提示页面

第三个页面是 点击搜索提示 跳转到商品列表页面

我们需要在这三个页面之间切换

这三个页面起的类名 假设分别是 default  tip  goods

1.先在 data 中定义另一个 current: 'default'

2.这三个页面使用 v-if  v-else-if  v-else 来控制显示和隐藏 判断条件是  current == '这三个页面起的类名'

3.点击改变页面或者其它的操作时 只需 改变 data 中的 current 的值即可

#### 书写点击品牌商直供时出现的问题

会报错`"TypeError: Cannot read properties of undefined (reading 'list_pic_url')"`但是数据可以渲染

原因: 接口数据为异步获取，界面渲染时会先判断数据情况，此时TagInfo.brace[0]并未定义故报错，当异步获取数据获取到时，通过v-if再次判断正常渲染，所以界面无错误。

解决办法:` v-if="brandList.data"` 原理即为 使用 v-if 判断相应的数据是否存在

### 从接口中请求过来的数据带有标签

我们使用 v-html 来渲染数据

```vue
      <div
        class="desc"
        v-html="detailData.info.goods_desc"
        v-if="detailData.info">
      </div>
      // 其中 detailData.info.goods_desc 是从后台请求的带有标签的数据
      // v-if 是因为 接口请求的数据并没有第一时间返回并渲染
```

我们使用 v-html 渲染数据之后 无法在 scss 下书写 样式, 百度上有解决办法; 试过效果不太好, 最好的办法是 单独将 css 样式 写出来, 然后在 页面中引用

#### 地图定位等使用的是高德地图

开发文档易懂好用, 

***注意:下面的代码是粘贴在 public 下的 index.html 文件中的***

注意: 项目上线了, 使用的是方式一:

```html
// 方式一:
<script type="text/javascript">
        window._AMapSecurityConfig = {
            serviceHost:'您的代理服务器域名或地址/_AMapService',  
            // 例如 ：serviceHost:'http://1.1.1.1:80/_AMapService',
            // 这是公司工作项目上线时公司给的 域名地址
        }
</script>
<script type="text/javascript" src="https://webapi.amap.com/maps?v=2.0&key=您申请的key值"></script> 
```

现在属于开发阶段:使用方式三:

```html
// 方式三:
<script type="text/javascript">
        window._AMapSecurityConfig = {
            securityJsCode:'您申请的安全密钥',
        }
</script>
<script type="text/javascript" src="https://webapi.amap.com/maps?v=2.0&key=您申请的key值"></script> 
```

#### 看快速上手文档即可

然后在我们书写的地图页面在    `mounted`钩子函数内,创建一个地图 实例移动端的适配问题:

```
var map = new AMap.Map('container');
```

#### 在实现地图定位的时候, 因为将 地图 页面单独写出来了, 我们需要将 定位所得 的地址 city 数据 返回至 首页页面

即 返回路由时 携带参数

+ ```js
      // 点击返回到 首页
      onClickLeft(city) {
        this.$route.params.message = city;
        this.$router.back("/home");
      },
  ```

+ ```js
  // 首页页面中接受这个参数, 我们使用 beforeRouteEnter
  // 为啥 这个函数 中的 this 不可以使用 自己 百度
  beforeRouteEnter(to, from, next) {
      next((vm) => {
        // 这里的 vm 相当于 指向外面的 this
        // 这里的 city 是 预先定义在 data 当中的
        vm.city = from.params.message;
      });
    },
  ```

+ 最后一步就是将该数据在页面中渲染

***其实上述的过程 可以简化 我们 在书写 首页的时候 只在搜索框左边 书写 地图的定位功能,意思就是 展示地址的这个地方 它 就是一个 地图定位 功能所返回的数据的渲染*** 

+ 然后我们 将点击 进入 搜索提示 的页面单独书写 并配置路由 使用 router-link to 跳转

#### 对上述问题的进一步解决

组件之间的传值 不能局限于一种方法,

vuex 

1. ###### store 为文件夹下的 index.js:

   ```js
   import Vue from 'vue'
   import Vuex from 'vuex'
   
   Vue.use(Vuex)
   
   export default new Vuex.Store({
     state: {
       cityInfo:{}
     },
     mutations: {
       // 使用的方法 this.$store.commit("upCityInfo",传递的参数)
       upCityInfo(state,val){ // val 载荷 一次只可以传递一个 {} []
         state.cityInfo=val;
       }
     },
     actions: {
     },
     modules: {
     }
   })
   ```

2. ###### 在 需要 发送数据的 map 下的 index.js 组件内采用映射的办法使用这个方法 并 传递参数

   ```vue
   <script>
   import { mapState, mapMutations, mapActions, mapGetters } from "vuex";
   
     methods: {
       // 映射传递的数据  有两种写法 数组 和 对象 两种写法
       // ...mapMutations(["upCityInfo"]),
       ...mapMutations({
         addCityInfo: "upCityInfo",
       }),
       // 点击时触发
       showGoods(val) {
         //   console.log(val);
         // 这里的 addCityInfo 适应射过来的方法
         this.addCityInfo(val);
         this.city = val.name;
         this.onClickLeft(val.name);
       },
     }
     /*
     // 这里需要 使用 这个映射的方法
     <li v-for="item in searchList" :key="item.id" @click="showGoods(item)">
         {{ item.name }}
     </li>
     */
     // 然后我们就可以在控制台的 vue-develoops 插件内看到数据
     // 获取数据我们 可以使用 this.$store.state.cityInfo  // cityInfo 是我们在 store 文件夹下预先写的共享数据的名字 后续深入访问遍历 可使用 . 语法
   </script>
   ```

   ##### 价格排序箭头的三种状态的切换
   
   类似于搜索框 三种状态的实现
   
   ```vue
   <template>
     // 在 data 中定义 current:'default'
     <span :class="`${current == 'default' ? '':'on'}`">价格</span>
     <span class="arror">
       <van-icon :color="current == 'up'?'#b4282d':''" name="arrow-up" />
       <van-icon :color="current == 'down'?'#b4282d':''" name="arrow-down" />
     </span> 
   </template>
   ```
   
   

## 有个必须注意的地方, 我们在使用路由传递 参数的时候 使用`params`传递参数; 如果使用 `this.$route.params.id` 等等来发送请求渲染页面,的话, 页面刷新 `params` 传递的参数会丢失; 

### 最优改动的解决办法,: 使用 `query` 传递参数, `query` 传递的参数在页面刷新后不会丢失

在渲染 地址列表数据的时候 后台 返回的 数据中 没有 用来表示 复选框状态的 数据 这里最优的解决方案是 需要我们进行处理

```js
cartList({
        openId: localStorage.getItem("openId"),
      }).then((res) => {
        // console.log(res.data.data);
        // 对数据进行处理 添加一条 属性 来表示 选中的状态
        // 新添加的属性 不是 响应式的数据 必须在 赋值 之前 操作
        res.data.data.forEach((element) => {
        // foreach 循环后添加 isSelected 的属性
          element.isSelected = false;
        });
        this.dataList = res.data.data;
      });
```

##### 购车列表页面的总价计算和全选与反选 等展示

```vue
<template>
    <!-- 购物车列表展示 -->
    <div class="goods-box">
      <van-swipe-cell v-for="item in dataList" :key="item.id">
        <van-checkbox v-model="item.isSelected"></van-checkbox>
        <van-card
          :num="item.number"
          :price="item.retail_price"
          :desc="item.goods_name"
          class="goods-card"
          :thumb="item.list_pic_url"
        />
        <template #right>
          <van-button
            square
            text="删除"
            type="danger"
            class="delete-button"
            @click="delList(item.id)"
          />
        </template>
      </van-swipe-cell>
    </div>
    <!-- 底部提交订单 -->
    <div>
      <van-submit-bar
        :price="getTotal * 100"
        button-text="提交订单"
        @submit="onSubmit"
      >
        <van-checkbox v-model="isAllSelected">全选</van-checkbox>
      </van-submit-bar>
    </div>
  </div>
</template>

<script>
import { ordersubmitAction } from "@/api/orders";
import { cartList, deleteAction } from "@/api/car";
export default {
  data() {
    return {
      dataList: [],
    };
  },
  // 实现全选的方式 监听 数据的变化 watch 推荐 computed
  computed: {
    // 全选
    // isAllSelected 函数形式 默认 只读
    // isAllSelected() {
    //   return this.dataList.every(ele=>ele.isSelected==true);
    // },
    isAllSelected: {
      get() {
        return this.dataList.every((ele) => ele.isSelected == true);
      },
      set(val) {
        // console.log(val);
        // val 为赋值之后的结果
        this.dataList.forEach((element) => {
          element.isSelected = val;
        });
        /* 可以简写
        if (val == true) {
          this.dataList.forEach(element => {
            element.isSelected = true;
          });
        }else{
          this.dataList.forEach(element => {
            element.isSelected = false;
          });
        }
        */
      },
    },

    // 计算 总价格
    getTotal() {
      // total 为上一次 循环计算的结果  current 为 当次循环的数据
      return this.dataList.reduce((total, current) => {
        if (current.isSelected) {
          return total + current.retail_price * current.number;
        } else {
          return total;
        }
      }, 0);
    },
  },
</script>

```

